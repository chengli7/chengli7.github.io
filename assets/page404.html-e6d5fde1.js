import{_ as o,r as p,o as n,c as h,a as s,b as e,e as r,d as a}from"./app-4af9f679.js";const i="/assets/1725520884850-e7e4c858.png",c="/assets/1725520877503-0d7ed543.png",d="/assets/1725520902824-647e7f6d.png",_="/assets/1725520912381-ef3fd3d8.png",l="/assets/1725520930382-aed56a62.png",g="/assets/1725520942207-d568696f.png",u="/assets/1725520968581-169be19d.png",m="/assets/1725520975873-9af5cc06.png",f="/assets/1725520984828-3548bf09.png",v="/assets/1725520995864-48c11df3.png",b="/assets/1725521001924-dab8b057.png",x={},L=a('<h2 id="一、问题描述" tabindex="-1"><a class="header-anchor" href="#一、问题描述" aria-hidden="true">#</a> 一、问题描述</h2><p>前端在本地调试完成后和服务端一起打包部署到线上，从一个前端路由跳转到另一个路由，页面能正常显示，但刷新页面后会返回404。该问题仅在前端的路由模式使用history模式时会出现，使用hash模式时不会出现该问题。问题复现步骤如下。</p><p>1、页面跳转到其他路由都能正常显示</p><p><img src="'+i+'" alt="1725520884850"></p><p>2、点击刷新按钮返回404</p><p><img src="'+c+'" alt="1725520877503"></p><h2 id="二、问题产生原因分析" tabindex="-1"><a class="header-anchor" href="#二、问题产生原因分析" aria-hidden="true">#</a> 二、问题产生原因分析</h2>',7),y={href:"https://v3.router.vuejs.org/zh/guide/",target:"_blank",rel:"noopener noreferrer"},R={href:"https://v3.router.vuejs.org/zh/guide/essentials/history-mode.html",target:"_blank",rel:"noopener noreferrer"},U=a('<p><img src="'+d+'" alt="1725520902824"></p><p>出现该问题主要是因为：当我们直接刷新带前端路由的页面时，后端服务会去controller里面寻找与路径地址相匹配的Mapping来处理请求，如下图所示：</p><p><img src="'+_+'" alt="1725520912381"></p><p>当访问地址为：http://ip:端口/组件上下文/v1/qjjy/subscript/callback时会调用crossRecordCallBack方法进行处理。第一次访问时的地址是http://ip:端口/组件上下文，服务端会直接返回index.html文件，页面正常显示。页面打开后前端路由发生跳转，此时的访问地址为：http://ip:端口/组件上下文/前端路由，刷新浏览器后向服务端发送该请求，但由于没有对应的Mapping来接收并处理该请求，因此服务端返回了404。</p><h2 id="三、-问题如何解决" tabindex="-1"><a class="header-anchor" href="#三、-问题如何解决" aria-hidden="true">#</a> <strong>三、</strong> <strong>问题如何解决</strong></h2><h5 id="_1、前端路由使用hash模式" tabindex="-1"><a class="header-anchor" href="#_1、前端路由使用hash模式" aria-hidden="true">#</a> **1、前端路由使用hash模式</h5>',6),k={href:"https://v3.router.vuejs.org/zh/guide/",target:"_blank",rel:"noopener noreferrer"},j={href:"https://cn.vuejs.org/",target:"_blank",rel:"noopener noreferrer"},B=a('<p>hash模式的工作原理：</p><p>在hash模式下，URL会带有一个特殊的哈希值，例如：http://example.com/#/home。当用户点击页面上的链接或执行路由跳转时，vue-router会监听URL的哈希变化，并根据哈希值匹配对应的路由，并加载相应的组件。</p><p>hash模式的工作原理非常简单，它利用浏览器的原生特性来实现路由功能。当URL的哈希发生变化时，浏览器不会向服务器发送请求，而是触发hashchange事件。由于这部分 URL 从未被发送到服务器，所以它不需要在服务端层面上进行任何特殊处理。vue-router会监听hashchange事件，并根据新的哈希值来匹配路由。一旦匹配到对应的路由，vue-router会渲染相应的组件，并更新页面的内容，实现无刷新的路由切换。</p><p>前端路由配置：</p><p><img src="'+l+'" alt="1725520930382"></p><p>页面刷新依然能正常访问：</p><p><img src="'+g+'" alt="1725520942207"></p><h5 id="_2、前端路由继续使用history模式" tabindex="-1"><a class="header-anchor" href="#_2、前端路由继续使用history模式" aria-hidden="true">#</a> 2、前端路由继续使用history模式</h5><p>如果不想要不是很美观的hash，我们可以继续使用 history 模式，这种模式充分利用 history.pushState API 来完成 URL 跳转而无须重新加载页面，但需要在服务端层面上进行特殊处理。具体处理方式为: 在服务端增加一个覆盖所有情况的候选资源，如果URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是前端 app 依赖的页面。简单来说：服务端需要添加一个配置类来处理404请求。</p><p>前端路由配置：</p><p><img src="'+u+'" alt="1725520968581"></p><p>后端添加配置类（下图两种方式任选其一即可）</p><p>方式一：</p><p><img src="'+m+'" alt="1725520975873"></p><p>方式二：</p><p><img src="'+f+'" alt="1725520984828"></p><p><strong>注意：</strong> 无论前端使用hash模式还是 history 模式，路由配置中的base都应配置为服务端组件上下文（案列中使用p<wbr>rocess.env.BASE_URL的值），p<wbr>rocess.env.BASE_URL获取的值是我们在vue.config.js配置的publicPath值，</p><p><img src="'+v+'" alt="1725520995864"></p><p>该值一般在.env文件中以VUE_APP_开头的变量进行定义。</p><p><img src="'+b+'" alt="1725521001924"></p><p>我们的前端资源是和服务端一起打包部署的，最终服务会部署在组件上下文目录下，访问时URL会带上组件上下文，如果base不配置为服务端组件上下文（base默认值为”/”）,前端会因为匹配不到路由返回404页面。</p><h2 id="四、总结" tabindex="-1"><a class="header-anchor" href="#四、总结" aria-hidden="true">#</a> 四、<strong>总结</strong></h2><p>本文主要介绍了前端路由跳转后刷新页面返回404的原因及两种解决方式（路由hash模式和history 模式）。如有错误，还请批评指正，欢迎大家一起学习交流！</p>',23);function E(A,P){const t=p("ExternalLinkIcon");return n(),h("div",null,[L,s("p",null,[e("1、查看"),s("a",y,[e("vue-router"),r(t)]),e(" 官方文档的"),s("a",R,[e("HTML5 History 模式"),r(t)]),e(" 章节可知：")]),U,s("p",null,[s("a",k,[e("vue-router"),r(t)]),e("是"),s("a",j,[e("vue.js官方"),r(t)]),e("推荐的路由管理器，用于构建单页应用程序（SPA）。它允许我们在vue应用中实现路由功能，从而实现页面之间的无刷新切换。vue-router提供了多种路由模式，其中之一是hash模式。hash模式是vue-router的默认路由模式，它通过URL的哈希（#）来管理路由。")]),B])}const V=o(x,[["render",E],["__file","page404.html.vue"]]);export{V as default};
